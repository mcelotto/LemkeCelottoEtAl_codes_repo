function [HX, HXY, HlX, HlXY, HiX, HiXY, ChiX, HshX, HshXY] = gaussian_method(X, pars)
%%% *function [HX, HXY, HlX, HlXY, HiX, HiXY, ChiX, HshX, HshXY] = gaussian_method(X, pars)*
%%%
%%% ### Description
%%% Estimate entropy values using the Gaussian Method.
%%%
%%% ### Inputs:
%%% - *X*: *nDimensions x nTrials x nStimuli* array including response data.
%%% - *pars*: parameter structure to check generated by build_parameters_structure.
%%%
% ### Further notes:
%
%   Copyright (C) 2009 Cesare Magri
%   Version 7.1.0
%
% -------
% LICENSE
% -------
% This software is distributed free under the condition that:
% 1. it shall not be incorporated in software that is subsequently sold;
% 2. the authorship of the software shall be acknowledged and the following article shall be properly cited in any publication that uses results generated by the software:
%
%      Magri C, Whittingstall K, Singh V, Logothetis NK, Panzeri S: A
%      toolbox for the fast information analysis of multiple-site LFP, EEG
%      and spike train recordings. BMC Neuroscience 2009 10(1):81;
%
% 3.  this notice shall remain in place in each source file.

BIASFUNC = @gaussian_bias;

% HiX, HiXY and ChiX are not computed for the gaussian case, null values
% are returned instead:
HiX  = NaN;
HiXY = NaN;
ChiX = NaN;

% We have to recompute Nc, Nt, maxNt (in the case this routine is called by
% quadratic extrapolation)
Nt    = pars.Nt;
Nc    = size(X,1);
maxNt = size(X,2);
totNt = sum(Nt);
Ns    = pars.Ns;

logOf2times2 = 2*log(2);
logOf2piTimesExp1 = log(2*pi*exp(1));

lind = findtrial(Nt, maxNt, Ns);
mask = false(size(X,2), size(X,3));
mask(lind) = true;

% H(X) and H_lin(X) -------------------------------------------------------
if pars.doHX || pars.doHlX

    % Removing mean:
    meanXvec = mean(X(:,mask),2);
    Xvec = X(:,mask) - meanXvec(:,ones(totNt,1));

    covPr = (Xvec * Xvec') ./ (totNt-1);
end

% H(X)
if pars.doHX
    HX = (Nc * logOf2piTimesExp1 + log(det(covPr))) / logOf2times2;

    % Bias correction:
    if pars.biasCorrNum==3
        HXbias = BIASFUNC(totNt, Nc);
        HX = HX - HXbias;
    end
else
    HX = 0;
end

% H_lin(X)
if pars.doHlX
    HlX = (Nc * logOf2piTimesExp1 + sum(log(diag(covPr)), 1)) / logOf2times2;

    % Bias correction:
    if pars.biasCorrNum==3
        HlXbias = Nc * BIASFUNC(totNt, 1);
        HlX = HlX - HlXbias;
    end
else
    HlX = 0;
end


% H(X|Y) and H_lin(X|Y) ---------------------------------------------------
if pars.doHXY || pars.doHlXY
    
    % Removing mean
    meanX = sum(X.*permute(mask(:,:,ones(Nc,1)), [3 1 2]), 2) ./ permute(Nt(:, ones(Nc,1)), [2 3 1]);
    Xzeromean = X - meanX(:, ones(maxNt,1), :);
    
    if Nc==1 
        % HlXY is never computed for Nc==1, if we got here it's cause we
        % need to compute H(X|Y):
        covPrsMat = covPrsForSingletonNc(Xzeromean, Nt, mask, maxNt, Ns);

        HXY  = (Nc * logOf2piTimesExp1 + log(covPrsMat(:))) / logOf2times2;

        HlXY = 0;

        % Bias correction:
        if pars.biasCorrNum==3
            HXYbias = BIASFUNC(Nt, 1);
            HXY = HXY - HXYbias;
        end
    else    
        HXY  = zeros(Ns,1);
        HlXY = zeros(Ns,1);
        
        for s=1:Ns
            covPrs = Xzeromean(:, 1:Nt(s), s) * Xzeromean(:, 1:Nt(s), s).' ./ (Nt(s)-1);

            if pars.doHXY
                detCovPrs = det(covPrs);

                HXY(s) = (Nc * logOf2piTimesExp1 + log(detCovPrs)) / logOf2times2;

                % Bias correction:
                if pars.biasCorrNum==3
                    HXYbias = BIASFUNC(Nt(s), Nc);
                    HXY(s) = HXY(s) - HXYbias;
                end
            end;

            if pars.doHlXY
                diagCovPrs = diag(covPrs);

                HlXY(s) = (length(diagCovPrs) * logOf2piTimesExp1 + sum(log(diagCovPrs))) / logOf2times2;

                % Bias correction:
                if pars.biasCorrNum==3
                    HlXYbias = Nc * BIASFUNC(Nt(s), 1);
                    HlXY(s) = HlXY(s) - HlXYbias;
                end
            end
        end
    end

    if ~pars.doHXY
        HXY = 0;
    end

    if ~pars.doHlXY
        HlXY = 0;
    end

else
    HXY  = 0;
    HlXY = 0;
end

% H_sh(X) and H_sh(X|Y) ---------------------------------------------------
if pars.doHshX || pars.doHshXY

    Xsh = shuffle_X_across_cells(X, Nt);

    if pars.doHshX
        % Removing mean:
        meanXshvec = mean(Xsh(:,mask),2);
        Xshvec = Xsh(:,mask) - meanXshvec(:,ones(totNt,1));
        
        covPshr = (Xshvec * Xshvec') ./ (totNt-1);
    
        HshX = (Nc * logOf2piTimesExp1 + log(det(covPshr))) / logOf2times2;
        
        % Bias correction:
        if pars.biasCorrNum==3
            HshXbias = BIASFUNC(totNt, Nc);
            HshX = HshX - HshXbias;
        end
    else
        HshX = 0;
    end

    % Remark: HshXY not computed for Nc==1
    if pars.doHshXY
        % Removing mean
        meanXsh = sum(Xsh.*permute(mask(:,:,ones(Nc,1)), [3 1 2]), 2) ./ permute(Nt(:, ones(Nc,1)), [2 3 1]);
        Xsh = Xsh - meanXsh(:,ones(maxNt,1),:);
    
        HshXY = zeros(Ns,1);
        for s=1:Ns
            covPshrs = Xsh(:, 1:Nt(s), s) * Xsh(:, 1:Nt(s), s).' ./ (Nt(s)-1);
            detCovPshrs = det(covPshrs);
            
            HshXY(s) = (Nc * logOf2piTimesExp1 + log(detCovPshrs)) / logOf2times2;
        end
        
        % Bias correction:
        if pars.biasCorrNum==3
            HshXYbias = BIASFUNC(Nt(:), Nc);
            HshXY = HshXY - HshXYbias;
        end
    else
        HshXY = 0;
    end

else
    HshX  = 0;
    HshXY = 0;
end


function covPrs = covPrsForSingletonNc(X, Nt, mask, maxNt, Ns)
    
% Removing first singleton dimension:
X2D = zeros(maxNt, Ns);
X2D(mask) = X(1,mask);

% Computing the variance (X.*X faster than X.^2):
covPrs = (sum(X2D.*X2D,1)) ./ (Nt.' - 1);

function pars = build_parameters_structure(X, opts, responseMatrixName, outputsList)

%%% *function pars = build_parameters_structure(X, opts, responseMatrixName, outputsList)*
%%%
%%% ### Description
%%% Build parameters structure for ENTROPY.m
%%%
%%% ### Inputs:
%%% - *X*: *nDimensionsX X nTrials X nY* 3D array including response data.
%%% - *opts*: options to compute the entropy.
%%% - *responseMatrixName*: name associated to the X matrix.
%%% - *outputsList*: cell array of char arrays of strings specifying which quantities to compute.
%%%
%%% ### Further notes:
%%%
%%% Recap of the fields in the parameter structure
%%% ----------------------------------------------
%%%
%%% X-related parameters:
%%%   - pars.Nc
%%%   - pars.Ns
%%%   - pars.Nt
%%%   - pars.maxNt
%%%   - pars.totNt
%%%
%%% TESTMODE-related parameters:
%%%   - pars.testmode
%%%
%%% METHOD-related parameters:
%%%   - pars.methodFunc
%%%   - pars.methodNum
%%%
%%% EXTRAPOLATION-related parameters
%%%   - pars.xtrp
%%%
%%% BIAS-related parameters:
%%%   - pars.biasCorrNum
%%%   - pars.biasCorrFuncName
%%%
%%% BOOTSTRAP-related parameters:
%%%   - pars.btsp
%%%
%%% OUTPUT-related parameters:
%%%   - pars.whereHX
%%%   - pars.whereHXY
%%%   - pars.whereHlX
%%%   - pars.whereHlXY
%%%   - pars.whereHiX
%%%   - pars.whereChiX
%%%   - pars.whereHshX
%%%   - pars.whereHshXY
%%%   - pars.whereHiXY
%%%   - pars.doHX
%%%   - pars.doHXY
%%%   - pars.doHlX
%%%   - pars.doHlXY
%%%   - pars.doHiX
%%%   - pars.doHiXY
%%%   - pars.doChiX
%%%   - pars.doHshX
%%%   - pars.doHshXY
%%%
%%% CHECKS-related parameters:
%%%   - pars.addChecks
%%%   - pars.numberOfSpecifiedOptions
%%%   - pars.Noutput
%%%
%   Copyright (C) 2009 Cesare Magri
%   Version 4
%
% -------
% LICENSE
% -------
% This software is distributed free under the condition that:
% 1. it shall not be incorporated in software that is subsequently sold;
% 2. the authorship of the software shall be acknowledged and the following article shall be properly cited in any publication that uses results generated by the software:
%
%      Magri C, Whittingstall K, Singh V, Logothetis NK, Panzeri S: A
%      toolbox for the fast information analysis of multiple-site LFP, EEG
%      and spike train recordings. BMC Neuroscience 2009 10(1):81;
%
% 3.  this notice shall remain in place in each source file.
%
% ----------
% DISCLAIMER
% ----------
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

opts.responseMatrixName = responseMatrixName;

if isempty(outputsList)
    msg = 'No output option specified';
    error(msg);
end


% X -----------------------------------------------------------------------
% The MEX functions require double type for working:
if ~strcmp(class(X), 'double')
    msg = 'Values of X must be of type double.';
    error(msg);
end
    
if ndims(X)<4
    [pars.Nc, size2ofX, pars.Ns] = size(X);
else
    msg = 'X matrix can be at most a 3-D matrix.';
    error(msg);
end


% NT ----------------------------------------------------------------------
% The MEX functions require double type for working:
if ~strcmp(class(opts.nt), 'double')
    msg = 'opts.nt must be of type double.';
    error(msg);
end
    
% If the number of trials per stimulus is constant, NT can be provided 
% as a scalar. In this case, the array version is built internally.
if isscalar(opts.nt)
    pars.Nt = ones(pars.Ns,1) * opts.nt;
    pars.maxNt = opts.nt;
    pars.totNt = opts.nt* pars.Ns;
    
    pars.trials_indxes = 1:pars.totNt;
else
    if length(opts.nt)~=pars.Ns
        msg = ['size(' responseMatrixName ',3) must match length(opts.nt). Try transposing nt.'];
        error(msg);
    end

    % X and NT compatibility:
    pars.Nt = opts.nt(:);
    pars.maxNt = max(pars.Nt);
    pars.totNt = sum(pars.Nt);
    
    pars.trials_indxes = findtrial(pars.Nt, pars.maxNt, pars.Ns);
end

% X and NT compatibility:
if pars.maxNt~=size2ofX
    msg = ['max(opts.nt) must be equal to size(' responseMatrixName ',2).'];
    error(msg);
end


% TEST MODE (optional) ----------------------------------------------------
pars.numberOfSpecifiedOptions = 0;
if isfield(opts, 'testMode') && opts.testMode
    pars.numberOfSpecifiedOptions = pars.numberOfSpecifiedOptions + 1;
    pars.testMode = true;
else
    pars.testMode = false;
end


% METHOD ------------------------------------------------------------------
pars.methodName = opts.method;
switch lower(opts.method)
    case {'dr'}
        pars.methodFunc = @direct_method;
        pars.methodNum = 1;
        
    case {'gs'}
        pars.methodFunc = @gaussian_method;
        pars.methodNum = 2;
        
    otherwise
        if pars.testMode
            pars.methodFunc = str2func(opts.method);
            pars.methodNum = -1;
        else
            msg = ['Method option ' opts.method ' not found.'];
            error(msg);
        end
end


% BIAS --------------------------------------------------------------------
switch lower(opts.bias)
    case 'naive'
        pars.biasCorrNum = 0;
    case 'qe'
        pars.biasCorrNum = 1;
    case 'pt'
        pars.biasCorrNum = 2;
    case 'gsb'
        pars.biasCorrNum = 3;
    otherwise
        pars.biasCorrNum = -1;
        pars.biasCorrFuncName = opts.bias;
end


% BTSP (optional) ---------------------------------------------------------
if isfield(opts, 'btsp')
    pars.numberOfSpecifiedOptions = pars.numberOfSpecifiedOptions + 1;
    
    if round(opts.btsp)~=opts.btsp
        msg = 'opts.btsp must be an integer.';
        error(msg);
    else
        pars.btsp = opts.btsp;
    end
else
    % No bootstrap:
    pars.btsp = 0;
end


% XTRP (optional) ---------------------------------------------------------
if isfield(opts, 'xtrp')
    pars.numberOfSpecifiedOptions = pars.numberOfSpecifiedOptions + 1;
    
    if round(opts.xtrp)~=opts.xtrp
        msg = 'opts.xtrp must be a positive integer.';
        error(msg);
    else
        pars.xtrp = opts.xtrp;
    end
else
    % No average over repetitions:
    pars.xtrp = 1;
end


% OUTPUT LIST -------------------------------------------------------------
% Checking which output-options have been selected and keeping track of the
% position they have in outputsList: this will allow do provide the outputs in
% the correct order.
pars.Noutput = length(outputsList); % number of ouputs

% outputsList = lower(outputsList);

% The following logical quantities need not to be saved into the pars
% structure:
whereHXYbs      = strcmpi(outputsList, 'hxybs'   );
whereHlXYbs     = strcmpi(outputsList, 'hixybs'  );
whereHiXbs      = strcmpi(outputsList, 'hixbs'   );
whereChiXbs     = strcmpi(outputsList, 'chixbs'  );
whereHshXYbs    = strcmpi(outputsList, 'hshxybs' );

% These instead are saved and used later:
pars.whereHX    = strcmpi(outputsList, 'hx'      );
pars.whereHXY   = strcmpi(outputsList, 'hxy'     ) | whereHXYbs;
pars.whereHlX   = strcmpi(outputsList, 'hlx'     );
pars.whereHlXY  = strcmpi(outputsList, 'hixy'    ) | whereHlXYbs;
pars.whereHiX   = strcmpi(outputsList, 'hix'     ) | whereHiXbs;
pars.whereChiX  = strcmpi(outputsList, 'chix'    ) | whereChiXbs;
pars.whereHshX  = strcmpi(outputsList, 'hshx'    );
pars.whereHshXY = strcmpi(outputsList, 'hshxy'   ) | whereHshXYbs;

% See note in ENTROPY regarding this quantity:
pars.whereHiXY  = strcmpi(outputsList, 'hixydef' );

if pars.Nc==1
    % If Nc=1 then computing HlX, HiX, ChiX or HshX is equivalent to
    % computing HX.
    pars.doHX    = any(pars.whereHX | pars.whereHlX | pars.whereHiX | pars.whereChiX | pars.whereHshX);
    
    % If Nc=1 then computing HlXY, HiX, HiXY or HshXY is equivalent to
    % computing HXY.
    pars.doHXY   = any(pars.whereHXY | pars.whereHlXY | pars.whereHiXY | pars.whereHshXY);
    pars.doHlX   = false;
    pars.doHlXY  = false;
    pars.doHiX   = false;
    pars.doHiXY  = false;
    pars.doChiX  = false;
    pars.doHshX  = false;
    pars.doHshXY = false;
    
    pars.doHlXYbs  = any(whereHlXYbs);
    pars.doHiXbs   = any(whereHiXbs);
    pars.doChiXbs  = any(whereChiXbs);
    pars.doHshXYbs = any(whereHshXYbs);
    
    % If Nc=1 we only compute the botstrap for HXY:
    pars.doHXYbs   = any(whereHXYbs) || pars.doHlXYbs || pars.doHiXbs || pars.doChiXbs || pars.doHshXYbs;
    pars.doHlXYbs  = false;
    pars.doHiXbs   = false;
    pars.doHiXYbs  = false;
    pars.doChiXbs  = false;
    pars.doHshXYbs = false;
    
else
    pars.doHX    = any(pars.whereHX   );
    pars.doHXY   = any(pars.whereHXY  );
    pars.doHlX   = any(pars.whereHlX  );
    pars.doHlXY  = any(pars.whereHlXY );
    pars.doHiX   = any(pars.whereHiX  );
    pars.doHiXY  = any(pars.whereHiXY );
    pars.doChiX  = any(pars.whereChiX );
    pars.doHshX  = any(pars.whereHshX );
    pars.doHshXY = any(pars.whereHshXY);
    
    pars.doHXYbs   = any(whereHXYbs);
    pars.doHlXYbs  = any(whereHlXYbs);
    pars.doHiXbs   = any(whereHiXbs);
    pars.doChiXbs  = any(whereChiXbs);
    pars.doHshXYbs = any(whereHshXYbs);
    
end

% For backward compatibility: if opts.btsp is provided but the quantities
% for which to apply bootstrap are not specified then bootstrap is computed
% for all possible quantities.
if ~any(pars.doHXYbs || pars.doHlXYbs || pars.doHiXbs || pars.doChiXbs || pars.doHshXYbs) && pars.btsp>0
    pars.doHXYbs   = pars.doHXY;
    pars.doHlXYbs  = pars.doHlXY;
    pars.doHiXbs   = pars.doHiX;
    pars.doChiXbs  = pars.doChiX;
    pars.doHshXYbs = pars.doHshXY;
    
end

% ADDCHECKS (optionals) ---------------------------------------------------
if isfield(opts, 'verbose') && opts.verbose
    pars.numberOfSpecifiedOptions = pars.numberOfSpecifiedOptions + 1;
    
    pars.addChecks = true;
    
else
    pars.addChecks = false;
    
end

if any(pars.addChecks)
	additional_checks(X, pars, opts);
end

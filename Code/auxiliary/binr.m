function [R_binned] = binr(R, nb, method, par)
%%% *function [R_binned] = binr(R, nb, method, par)*
%%%
%%% ### Description
%%% Discretize the input matrix *R* .
%%%
%%% ### Inputs:
%%% - *R*: *nDims X nTrials* input matrix to be discretized
%%% - *nb*: number of bins array (can be a scalar or a vector of `size(nb) = size(R,1)`). If a scalar is specified then all dimensions are binned using the same number of bins. Alternatively, each dimension is binned using its specific number of bins. 
%%% - *method*: binning method (can be a scalar or a cell array of `size(method) = size(R,1)`). If a scalar is specified then all dimensions are binned using the same method. Alternatively, each dimension is binned using its specific method.
%%% - *par*: optional parameters
%%%
%%% ### Outputs:
%%% - *R_binned*: *nDims X nTrials* binned matrix.
%%%
%%% ### Further notes
%%% #### Binning methods and parameters
%%% The table below describe the binning options which are built-in in the toolbox. Alternatively, users can define and plug-in their custom binning methods (see [Building and calling custom binning functions](Building and calling custom binning functions)"Building and calling custom binning functions" section).
%%%
%%% Some of the built-in binning options allow a parameter to be specified.
%%% Parameters can be passed in a similar fashion to the options:
%%% - if a single parameter needs to be specified for all values of *R*, it can be passed directly or in the form of a one dimensional cell-array;
%%% - if different parameters need to be specified for the different binning options or values of *R*, then a cell array of length *nDims* must be passed to the function where each field specifies the binning option for the i-th value. To skip the parameter for a value, just pass an empty array [] for the corresponding index.
%%%
%%%   | Option        | Description                                           |
%%%   |---------------|-------------------------------------------------------|
%%%   | `'eqpop'`     | Equipopulated binning: the width of the bins is selected so that each bin contains (approximately) the same number of values. Using `'eqpop'` option for *R* values which are not continuous in nature (i.e., which contain several repeated values) may result in the bins being poorly equipopulated. |
%%%
%%%
%   Copyright (C) 2009 Cesare Magri
%   Version 1.1.0
%
% -------
% LICENSE
% -------
% This software is distributed free under the condition that:
% 1. it shall not be incorporated in software that is subsequently sold;
% 2. the authorship of the software shall be acknowledged and the following article shall be properly cited in any publication that uses results generated by the software:
%
%      Magri C, Whittingstall K, Singh V, Logothetis NK, Panzeri S: A
%      toolbox for the fast information analysis of multiple-site LFP, EEG
%      and spike train recordings. BMC Neuroscience 2009 10(1):81;
%
% 3.  this notice shall remain in place in each source file.

if nargin < 3
    error("binr.m: not enough input arguments. See `help binr` for usage info");
end

if nargin < 3
    error("binr.m: not enough input arguments. See `help binr` for usage info");
end

[nDims, ~] = size(R);

nbLEN = length(nb);
if nbLEN~=nDims
    if nbLEN==1
        internalNb = ones(nDims,1) .* nb;
    else
        msg = ['Lenght of number-of-bins array can either be one or match size(' inputname(1) ',1).'];
        error('binr:NbLenghtMismatch', msg);
    end
else
    internalNb = nb;
end

% Making opt of type cell-array if it is of type char:
if ischar(method)
    method = {method};
elseif ~iscell(method)
    msg = 'Option field can either be of type char of cell-array.';
    error('binr:illegalOptType', msg);
end

optLEN = length(method);
if optLEN~=nDims
    if optLEN==1
        internalOpt = cell(nDims,1);
        internalOpt(:) = method;
    else
        msg = ['Number of binning options can either be one or match size(' inputname(1) ',1).'];
        error('binr:optLengthMismatch', msg);
    end
else
    internalOpt = method;
end

if nargin==5
    if ~iscell(par)
        par = {par};
    end
    
    parLEN = length(par);
    if parLEN~=nDims
        if parLEN==1
            internalPar = cell(nDims,1);
            internalPar(:) = par;
        else
            msg = ['Number of parameters can either be one or match size(' inputname(1) ',1).'];
            error('binr:optLengthMismatch', msg);
        end
        
    else
        internalPar = par;
    end
end


for k=1:nDims

    switch internalOpt{k}
        case {'eqpop'}
            isBuiltinFunc = true;
        otherwise
            isBuiltinFunc = false;
    end
    
    if length(unique(R(k,:))) < internalNb(k)
        msg = "Selected number of bins higher than the available values in R. Reducing bin number to " + length(unique(R(k,:)));
        internalNb(k) = length(unique(R(k,:)));
        warning('binr:tooManyBins',msg);
    end
    
    edgesFunc = str2func(internalOpt{k});
    
    if isBuiltinFunc && nargin==5 && ~isempty(internalPar{k})
        % Built-in function are allowed a more elaborate input:
        outef = edgesFunc(R(k,:), internalNb(k), internalPar{k});
    else
        msg = ['Only ''eqpop'' binning allowed.'];
        error('binr:wrongBinningOption', msg);
    end

    % Performing the actual binning:
    R_binned(k,:) = outef;
end

% Bin values are from 0 to NB:
R_binned = R_binned - 1;
